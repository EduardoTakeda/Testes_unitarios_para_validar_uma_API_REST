
Com os testes unitários é possível montar um projeto bem documentado
Frameworks: JUnit, Mockito e Hamcrest
JPARepository classe que tem a responsabilidade de conversar com o
 banco de dados, criação, leitura, atualização, exclusão e implementar 
outras operações no bd, retorna os dados como um tipo Optional onde 
são feitas operações seguras e posteriormente realizar validações 
com o Optional
O JPA faz todo o gerenciamento com o banco de dados (Spring data jpa)
A classe sevice recebendo anotação @Service, para indicar que essa 
classe será gerenciada pelo Spring, todo o ciclo de vida dela será
gerenciada pelo Spring
É só injetar a classe service na classe controller para que o String 
faça o gerenciamento 

OBS: na construção do "when", se faz uso do Mockito.when no início

Classe controller, onde acontece todas as operações iniciais do padrão REST
@RestController :indicando que é uma classe controladora e voltada a 
uma API_REST e somente com a parte de dados

A classe controller faz a a interação com o postman, nessa classe
existe três métodos para ser testado

A classe Sevice já testada, quando for testar o controller a service
servirá como um mock, objeto dublê nos testes
É preciso gerar um método de setup
Antes de realizar cada teste, é preciso configurar o objeto mockMvc

Foi criado uma classa JsonConvertionUtils para realizar os testes
no BeerControllerTest
O JsonConvertionUtils converte todos os objetos para uma json para
a simulação de uma chamada do teste unitario numa API

Quando o teste não tem um retorno (um void), o assert não tem como
ser aplicado, nesses casos se usa o verify do Mockito
exemplo, no BeerServiceTest testando a exclusão

Sobre TDD, criar primeiro testes que falham , para depois criar
códigos que atendam os testes de formabem legível e de fácil manutenção
exemplo: nos 3 testes sobre o incremento da classe BeerService, o increment
sofreu alteração para cada teste aplicado para fins de aprimoramento do código
Fazer um desenvolvimento de código orientado por teste



